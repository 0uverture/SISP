1)
Backward validation is better when you have fewer queries than facts as backwards validation will result in a number of trees <= to the number of queries.
Forwards validation will result in a number of tree >= to the number of known facts.



2)
getPrems(KB, Q)
	prems = new list;
	for clause in KB
		if(c.conclusion == Q)
			prems.add(C.premises);
	return prems;

backwardsEntails(KB, Q, his)
	if(agenda.contains(Q)) 
		return true;
	prems = getPrems(KB, Q);
	for pl in prems
		entails = false;
		for p in pl
			if(his.contains(p)) return false;
			his.add(p);
			if(!backwardsEntails(KB, p, his))
				entails = false;
				break;
			else
				entails = true;
				his.remove(p);
		if(entails)
			agenda.add(Q);
			return true;
	return false;

pl-bc-Entails(KB, Q) =
	his = new list;
	return backwardsEntails(KB, Q, his);

KB:
P => Q
L^M => P
B^L => M
A^P => L
A^B => L
A
B

3)
Since A requires C and is in a cyclical dependence with G, KB does not entail A.

4)
If we assume that getPrems, agenda.contains, his.contains could be converted to have constant complexity (e. g. via hashset), this would run in linear time since each premise is at most verified as being true or false once.